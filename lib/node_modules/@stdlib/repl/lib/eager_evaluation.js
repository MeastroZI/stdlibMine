/* eslint-disable max-len */
/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle, no-restricted-syntax, no-invalid-this */

'use strict';

// MODULES //

var readline = require( 'readline' );
var inspect = require( 'util' ).inspect;
var logger = require( 'debug' );
var parse = require( 'acorn' ).parse;
var replace = require( '@stdlib/string/replace' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var processCommand = require( './process_command.js' );
var compileCommand = require( './compile_command.js' );


// VARIABLES //

var debug = logger( 'repl:eager_evaluation' );
var AOPTS = {
	'ecmaVersion': 'latest'
};
var tempDB = {
	'base_sin': {
		'isPure': true
	}
};


// MAIN //

/**
* Constructor for creating a eager evaluator.
*
* @private
* @param {REPL} repl - repl instance
* @param {Object} rli - readline instance
* @param {Boolean} enabled - boolean indicating whether the syntax-highlighter should be initially enabled
* @returns {EagerEvaluator} eager-evaluator instance
*/
function EagerEvaluator( repl, rli, enabled ) {
	// Cache a reference to the provided REPL instance:
	this._repl = repl;

	// Cache a reference to the readline interface:
	this._rli = rli;

	// Cache a reference to the command array:
	this._cmd = repl._cmd;

	// Flag indicate weather eagerevaluation is enable or not
	this._enabled = enabled;

	// Flag indicate weather preview is on terminal or not
	this._isPreview = false;

	return this;
}

/**
* Callback for handling a "keypress" event.
*
* @name onKeyPress
* @memberof EagerEvaluator.prototype
* @type {Function}
* @param {string} data - input data
* @param {(Object|void)} key - key object
* @returns {void}
*
*/
setNonEnumerableReadOnly(EagerEvaluator.prototype, 'onKeypress', function onKeypress() {
	var cursorPosition;
	var executable;
	var nlInd;
	var code;
	var opts;
	var pre;
	var res;
	var tmp;

	if (!this._enabled || this._rli.line === '' || this._repl._completerEngine.isNavigating()) {
		return;
	}

	code = this._cmd.join('\n') + this._rli.line;
	opts = {
		'timeout': this._repl._timeout,
		'displayErrors': false,
		'breakOnSigint': true // Node.js >=6.3.0
	};
	if (!this.isSideEffectFree(code)) {
		debug('code have side effect');
		return;
	}
	debug('try to process command');
	tmp = processCommand(code);
	if (tmp instanceof Error) {
		debug( 'getting error %s', tmp.message );
		return;
	}
	debug('try to compile command');
	executable = compileCommand(tmp);
	if (executable instanceof Error) {
		debug( 'getting error %s', executable.message );
		return;
	}
	try {
		if ( this._repl._sandbox ) {
			res = executable.compiled.runInContext( this._repl._context, opts );
		} else {
			res = executable.compiled.runInThisContext( opts );
		}
	} catch (err) {
		debug( 'getting error when executing the command %s', err.message );
		return;
	}

	res = inspect(res);
	nlInd = res.indexOf('\n');
	if ( nlInd !== -1 ) {
		res = res.slice(0, nlInd ) + '...';
	}
	cursorPosition = this._rli.cursor;
	pre = replace( this._repl._outputPrompt, '%d', (this._repl._count+1).toString() );
	this._repl._ostream.write( '\n\u001b[90m' + pre + res + '\u001b[0m' );
	readline.moveCursor(this._repl._ostream, 0, -1);
	readline.cursorTo(this._repl._ostream, cursorPosition + this._repl.promptLength() );
	this._isPreview = true;
	debug( 'sucess' );
});

/**
* Callback which should be invoked**before** a "keypress" event.
*
* @name beforeKeyPress
* @memberof EagerEvaluator.prototype
* @type {Function}
* @param {string} data - input data
* @param {(Object|void)} key - key object
* @returns {void}
*
*/
setNonEnumerableReadOnly(EagerEvaluator.prototype, 'beforeKeypress', function beforeKeypress() {
	if (!this._isPreview ) {
		return;
	}
	if ( this._isPreview ) {
		this.clear();
	}
});

/**
* Function to determine if code is side-effect-free.
*
* @name isSideEffectFree
* @memberof EagerEvaluator.prototype
* @type {Function}
* @param {string} code - input code
* @returns {boolean} - boolean indicate weather code is side effect free or not.
*
*/
setNonEnumerableReadOnly( EagerEvaluator.prototype, 'isSideEffectFree', function isSideEffectFree( code ) {
	var ast;
	var i;

	try {
		ast = parse( code, AOPTS );
	}
	catch (err) {
		debug( 'getting error when generating AST %S ', err );
		return false;
	}
	// Iterate from each node in body
	for ( i = 0; i < ast.body.length; i++ ) {
		if ( !traverse( ast.body[ i ] ) ) {
			return false;
		}
	}
	return true;

	/**
	* Function which recursivly traverse from the node and tells weather node is side effect free or not.
	*
	* @private
	* @param {Object} node - ast node
	* @returns {Boolean} - boolean indicating whether the node is side effect free or not
	*/
	function traverse(node) {
		var fname;
		var i;
		if ( !node ) {
			return false;
		}
		if ( node.type === 'Literal' || node.type === 'Identifier' || node.type === 'MemberExpression' ) {
			return true;
		}
		if ( node.type === 'BinaryExpression' ) {
			if ( traverse( node.left ) && traverse( node.right ) ) {
				return true;
			}
		}
		else if ( node.type === 'ExpressionStatement' ) {
			if ( traverse( node.expression ) ) {
				return true;
			}
		}
		else if ( node.type === 'CallExpression' ) {
			fname = getFunctionName( node.callee );
			if ( tempDB[fname] && tempDB[fname].isPure ) {
				// Iterating through arguments
				for ( i = 0; i < node.arguments.length; i++ ) {
					if ( !traverse( node.arguments[ i ] ) ) {
						return false;
					}
				}
				return true;
			}
		}
		return false;
	}

	/**
	* Get the underscore seprate function name for the member function call.
	*
	* @private
	* @param {Object} node - ast node
	* @returns {string} - underscore seprated function name for the member function call
	*/
	function getFunctionName( node ) {
		if ( !node ) {
			return '';
		}
		if ( node.type === 'MemberExpression' ) {
			return getFunctionName(node.object) + '_' + node.property.name;
		}
		if ( node.type === 'Identifier' ) {
			return node.name;
		}
		return '';
	}
} );

/**
* Method to clear the eagerly evaluated text.
*
* @name clear
* @memberof EagerEvaluator.prototype
* @type {Function}
* @returns {void}
*
*/
setNonEnumerableReadOnly( EagerEvaluator.prototype, 'clear', function clear( ) {
	var cursorPosition;

	cursorPosition = this._rli.cursor;
	readline.moveCursor( this._repl._ostream, 0, 1 );
	readline.clearLine( this._repl._ostream, 0 );
	readline.moveCursor( this._repl._ostream, 0, -1 );
	readline.cursorTo( this._repl._ostream, cursorPosition + this._repl.promptLength() );
	this._isPreview = false;
} );


// EXPORTS //

module.exports = EagerEvaluator;
