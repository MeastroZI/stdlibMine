/* eslint-disable max-len */
/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-underscore-dangle, no-invalid-this */

'use strict';

var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var defineProperty = require( '@stdlib/utils/define-property' );
var min = require( '@stdlib/math/base/special/min' );
var round = require( '@stdlib/math/base/special/round' );
var max = require( '@stdlib/math/base/special/max' );
var minmaxn = require( '@stdlib/math/base/special/minmaxn' );
var mergeFcn = require( '@stdlib/utils/merge' ).factory;
var objectKeys = require( '@stdlib/utils/keys' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var floor = require( '@stdlib/math/base/special/floor' );
var defaults = require( './default.js' );
var setXaxis = require( './props/xaxis/set.js' );
var getXaxis = require( './props/xaxis/get.js' );
var setYaxis = require( './props/yaxis/set.js' );
var getYaxis = require( './props/yaxis/get.js' );
var setRows = require( './props/rows/set.js' );
var getRows = require( './props/rows/get.js' );
var setCols = require( './props/cols/set.js' );
var getCols = require( './props/cols/get.js' );
var setBarColor = require( './props/barColor/set.js' );
var getBarColor = require( './props/barColor/get.js' );
var setLabelColor = require( './props/labelColor/set.js' );
var getLabelColor = require( './props/labelColor/get.js' );
var setMarker = require( './props/marker/set.js' );
var getMarker = require( './props/marker/get.js' );
var primitive = require( './../base/lib' );


// VARIABLES //

var merge = mergeFcn({
	'extend': false
});

// List of private properties (note: keep in alphabetical order):
var PRIVATE_PROPS = [
	'_x',
	'_y',
	'_rows',
	'_cols',
	'_barColor',
	'_marker',
	'_labelColor'
];

var Poptions = {
	'padBottom': 2
};


// MAIN //

/**
* BarPlot constructor.
*
* @constructor
* @param {Options} options - constructor options
* @param {number} [rows] - number of character in height for plot
* @param {number} [cols] - number of character in width for plot
* @param {Array} [xaxis] - xaxis data
* @param {Array} [yaxis] - yaxis data
* @throws {TypeError} must provide valid options
* @returns {Plot} Plot instance
*
* @example
* var barplot = new BarPlot();
*/
function BarPlot() {
	var options;
	var nargs;
	var keys;
	var opts;
	var key;
	var i;

	for ( i = 0; i < PRIVATE_PROPS; i++ ) {
		defineProperty( this, PRIVATE_PROPS[ i ], {
			'configurable': false,
			'enumerable': false,
			'writable': true,
			'value': null
		});
	}
	defineProperty( this, '_primitive', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': new primitive(Poptions)
	});
	nargs = arguments.length;
	opts = defaults();
	if ( nargs ) {
		options = arguments[ 0 ];
	}
	else {
		options = {};
	}
	opts = merge( opts, options );
	keys = objectKeys( opts );
	for ( i = 0; i < keys.length; i++ ) {
		key = keys[ i ];
		this[ key ] = opts[ key ];
	}

	// Initilize primitive class

	this._primitive.setSize = {
		'rows': this._rows,
		'cols': this._cols
	};
	return this;
}

/**
 * Main method which add label, draw bars according to the requirement.
 *
 * @name draw
 * @memberof Primitive.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(BarPlot.prototype, 'draw', function draw() {
	var finalCordx;
	var finalCordy;
	var ybar;
	var xbar;
	var xlim;
	var ylim;
	var temp;
	var i;

	finalCordx = [];
	finalCordy = [];
	this.addLableX();
	this._primitive.drawFrame();
	temp = scaleBar( this._x, this._y, this._cols - this._primitive._padLeft - this._primitive._padRight );
	xbar = temp[ 0 ];
	ybar = temp[ 1 ];
	xlim = getLim( xbar );
	ylim = getLim( ybar );
	for ( i = 0; i < xbar.length; i++ ) {
		finalCordx.push( scale( xbar[ i ], this._cols - this._primitive._padLeft - this._primitive._padRight, xlim, this._primitive._padLeft ) );
	}
	this.addCategory( finalCordx );
	for ( i = 0; i < ybar.length; i++ ) {
		finalCordy.push( scale( ybar[ i ], this._rows - this._primitive._padBottom - this._primitive._padTop, ylim, this._primitive._padBottom ) );
	}
	for ( i = 0; i < xbar.length; i++ ) {
		this._primitive.drawRectangle( finalCordy[ i ], finalCordx[ i ], this._barColor, this._marker );
	}
});

/**
 * Render and display the result.
 *
 * @name render
 * @memberof Primitive.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(BarPlot.prototype, 'render', function render() {
	this._primitive.build();
	this._primitive.show();
});

/**
 * Add x label and tics.
 *
 * @name addLableX
 * @memberof Primitive.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(BarPlot.prototype, 'addLableX', function addLableX() {
	var pointGap;
	var xpos;
	var step;
	var elm;
	var mx;
	var y;
	var i;

	pointGap = 1;
	xpos = this._primitive._padBottom;
	y = [];
	mx = minmaxn.apply( null, this._y );

	// Adding extra padding on left according to the number range of the tics
	this._primitive.padLeft += mx[ 1 ].toString().length + 2;

	// Calculating steps of number according the rows
	step = ( mx[ 1 ] - mx[ 0 ] ) / ( this._rows - this._primitive._padTop - this._primitive._padBottom );

	// Changing precision of step to 1 dig after decimal
	step = ceil( step * 10 ) / 10;
	i = mx[ 0 ];
	while ( i <= mx[ 1 ] ) {
		elm = new Array( 3 );
		elm[ 1 ] = 0;
		elm[ 0 ] = xpos;
		elm[ 2 ] = i.toString();
		y.push( elm );
		i += step;
		i = round( i * 10 ) / 10;
		xpos += pointGap;
	}
	this._primitive.addTic( false, this._labelColor, [], y );
});

/**
 * Add categories for the bars.
 *
 * @name addCategory
 * @memberof Primitive.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(BarPlot.prototype, 'addCategory', function addCategory( BarPositions ) {
	var temp;
	var cat;
	var elm;
	var i;

	cat = [];
	for ( i = 0; i < BarPositions.length; i++ ) {
		// row, col, str
		elm = new Array( 3 );

		// Taking middle
		temp = floor( ( BarPositions[i][1] + BarPositions[i][0] ) / 2 );
		elm[ 0 ] = 0;
		elm[ 1 ] = temp;
		elm[ 2 ] = ( i + 1 ).toString();
		cat.push( elm );
	}
	this._primitive.addTic( true, this._labelColor, cat );
});

/**
 * @name xaxis
 * @memberof Primitive.prototype
 * @type {Array}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'xaxis', {
	'configurable': false,
	'enumerable': true,
	'set': setXaxis,
	'get': getXaxis
});

/**
 * @name yaxis
 * @memberof Primitive.prototype
 * @type {Array}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'yaxis', {
	'configurable': false,
	'enumerable': true,
	'set': setYaxis,
	'get': getYaxis
});

/**
 * @name rows
 * @memberof Primitive.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'rows', {
	'configurable': false,
	'enumerable': true,
	'set': setRows,
	'get': getRows
});

/**
 * @name cols
 * @memberof Primitive.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'cols', {
	'configurable': false,
	'enumerable': true,
	'set': setCols,
	'get': getCols
});

/**
 * @name barColor
 * @memberof Primitive.prototype
 * @type {string}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'barColor', {
	'configurable': false,
	'enumerable': true,
	'set': setBarColor,
	'get': getBarColor
});

/**
 * @name labelColor
 * @memberof Primitive.prototype
 * @type {string}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'labelColor', {
	'configurable': false,
	'enumerable': true,
	'set': setLabelColor,
	'get': getLabelColor
});

/**
 * @name marker
 * @memberof Primitive.prototype
 * @type {string}
 * @throws {TypeError}
 *
 */
defineProperty( BarPlot.prototype, 'marker', {
	'configurable': false,
	'enumerable': true,
	'set': setMarker,
	'get': getMarker
});

/**
* Find the best suitable width of the bars according to the width.
*
* @private
*
* @type {Function}
* @param {Array} x - date of x axis
* @param {Array} y - data of y axis
* @param {number} containerWidth - width of the container
* @returns {Array} array of scale represent width and height of bar
* */
function scaleBar( x, y, containerWidth ) {
	var dataPoints;
	var widthHalf;
	var barWidth;
	var awidth;
	var width;
	var bins;
	var xbar;
	var ybar;
	var i;

	width = 0.8;
	dataPoints = x.length;
	awidth = floor( containerWidth / dataPoints );

	// Scaling the width scale, with 101 character width and 10 data points bar width scale of 0.8 works great, so scale is realtive to it, by scale them with the ratio of ( containerWidht / dataPoints ) / ( 101 / 10 )
	width *= ( ( containerWidth / dataPoints ) * ( 10 / 101 ) );

	// 0.8 is the max width we can use because we also need to care about the spaces between bars
	width = min( width, 0.8 );

	// This normalization is done to reduce the rounding error, effect of this can be seen when the width is of  16 char or less and atleast 14 bars
	barWidth = floor( awidth * width );
	width *= ( barWidth / ( awidth * width ) );
	bins = x.length;
	widthHalf = width / 2;
	xbar = [];
	ybar = [];
	for ( i = 0; i < bins; i++ ) {
		xbar.push( [ x[ i ] - widthHalf, x[ i ] + widthHalf ] );
		ybar.push( [ 0, y[ i ] ] );
	}
	return [ xbar, ybar ];
}

/**
* Convert the elms value in scale of between bins and pad.
*
* @private
*
* @type {Function}
* @param {Array} elms - array of value need to scale
* @param {Number} bins - upper value under which we have to scale
* @param {Array} lim - array of high and low value of data
* @param {number} pad - pading from left
* @returns {Array} array of range value
* */
function scale( elms, bins, lim, pad ) {
	var sElm;
	var elm;
	var arr;
	var i;

	arr = [];
	for ( i = 0; i < elms.length; i++ ) {
		elm = elms[i];

		// Converting value in range of 0 to 1
		sElm = ( elm - lim[ 0 ] ) / ( lim[ 1 ] - lim[ 0 ] );
		arr.push( round( pad + ( ( bins - 1 ) * sElm ) ) );
	}
	return arr;
}

/**
* Helper function which give the higher and lower value of the bars.
*
* @private
*
* @name getLim
* @type {Function}
* @param {Array} elms - target elements
* @returns {Array} return min and max value of elms
* */
function getLim( elms ) {
	var temp;
	var mn;
	var mx;
	var i;

	for ( i = 0; i < elms.length; i++ ) {
		temp = elms[i];
		mn = min( mn, temp[ 0 ] );
		mx = max( mx, temp[ 1 ] );
	}
	return [ mn, mx ];
}


// EXPORTS //

module.exports = BarPlot;
