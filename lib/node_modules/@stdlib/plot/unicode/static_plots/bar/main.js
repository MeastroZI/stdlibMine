var setNonEnumerableReadOnly = require('@stdlib/utils/define-nonenumerable-read-only-property');
var defineProperty = require('@stdlib/utils/define-property');
var mergeFcn = require( '@stdlib/utils/merge' ).factory;
var objectKeys = require( '@stdlib/utils/keys' );
var defaults = require('./default.js');
var setXaxis = require( './props/xaxis/set.js' );
var getXaxis = require( './props/xaxis/get.js' );
var setYaxis = require( './props/yaxis/set.js' );
var getYaxis = require( './props/yaxis/get.js' );
var setRows = require( './props/rows/set.js' )
var getRows = require( './props/rows/get.js' )
var setCols = require( './props/cols/set.js' )
var getCols = require( './props/cols/get.js' );
var setVertical = require( './props/vertical/set.js' );
var getVertical = require( './props/vertical/get.js' );
var primitive = require( '../base/lib' );
// var scale_bar = require( './utils/scale_bar.js' )

/**
 * xpos
 * ypos
 * 
 */
var merge = mergeFcn({
	'extend': false
});

// List of private properties (note: keep in alphabetical order):
var PRIVATE_PROPS = [
	'_x',
    '_y',
    '_primitive',
    '_rows',
    '_cols',
    '_vertical'
];

var options = {
    'isFill' : true

}

function barplot() {
    for( i = 0; i < PRIVATE_PROPS; i++ ) {
        defineProperty( this, PRIVATE_PROPS[ i ], {
            'configurable': false,
			'enumerable': false,
			'writable': true,
			'value': null
        } )
    }

    this._x = [];
    this._y = [];
    this._primitive = new primitive();
    var options;
	var nargs;
	var opts;

    nargs = arguments.length;
    opts = defaults();
    if ( nargs ) {
        options = arguments[ 0 ];
    }
    else {
        options = {}
    }
    opts = merge( opts, options );
    keys = objectKeys( opts );
    for ( i = 0; i < keys.length; i++ ) {
        key = keys[i];
        this[ key ] = opts[ key ];
    }

    // initilize primitive class

    this._primitive.setSize(this._rows, this.cols )
    return this;
}

setNonEnumerableReadOnly(barplot.prototype, 'draw', function draw() {
    this.addLableX();
    var ybar;
    var xbar;
    var temp;
    var i;
    if ( this._vertical ) {
        temp = scale_bar_vertical(this._x, this._y, this._rows - this._primitive._padTop - this._primitive._padBottom );
        xbar = temp[1];
        ybar = temp[0];
    }
    else {
        temp = scale_bar(this._x, this._y, this._cols - this._primitive._padLeft  - this._primitive._padRight );
        xbar = temp[0];
        ybar = temp[1];
    }
    var xlim = getLim(xbar)
    var ylim = getLim(ybar)
    // var finalCordx = scale( xbar, this._x.length - this._primitive._padLeft - this._primitive._padRight, getLim(xbar), this._ )
    var finalCordx = [];
    var finalCordy = [];

    for ( i = 0; i < xbar.length; i++ ) {
        finalCordx.push( scale( xbar[i], this._cols - this._primitive._padLeft - this._primitive._padRight, xlim, this._primitive._padLeft ) );
    }
    this.addCategory( finalCordx );
    for ( i = 0; i < ybar.length; i++ ) {
        finalCordy.push( scale( ybar[i], this._rows - this._primitive._padBottom - this._primitive._padTop, ylim, this._primitive._padBottom ) );
    }
    for ( i = 0; i < xbar.length; i++ ) {
        this._primitive.draw_rectangle( finalCordy[i], finalCordx[i] );
    }
});

setNonEnumerableReadOnly(barplot.prototype, 'render', function render() {
    this._primitive.build();
    this._primitive.show();
});

setNonEnumerableReadOnly(barplot.prototype, 'addLableX', function addLableX() {
    var xpos = this._primitive._padBottom;
    var pointGap = 1;
    var y = [];
    var mx;
    var i;
    var gap;
    
    x = [ ...this._x ];
    mx = minmax( this._y );

    this._primitive._padLeft += mx[1].toString().length ;
    this._primitive.drawFrame();
    if ( this._vertical ) {
        gap = ( mx[1] - mx[0] ) / ( this._cols - this._primitive._padLeft - this._primitive._padRight );
    }
    else {
        gap = ( mx[1] - mx[0]) / (this._rows - this._primitive._padTop - this._primitive._padBottom );
    }

    gap = Math.ceil(gap * 10) / 10;
    i = mx[0];
    while ( i <= mx[1] ) {
        var elm = new Array(3);
        elm[1] = 0;
        elm[0] = xpos;
        elm[2] = i.toString();
        y.push(elm);
        i += gap;
        i =  Math.round(i * 10) / 10;
        xpos += pointGap;
    }

    this._primitive.addTic( [], y );

});

setNonEnumerableReadOnly(barplot.prototype, 'addCategory', function addCategory( BarPositions ) {
    var i;
    var cat = [];
    var elm;
    var temp;
    for ( i = 0; i < BarPositions.length; i++ ) {
        elm = new Array(3);
        temp = Math.floor( ( BarPositions[i][1] + BarPositions[i][0] ) / 2 );
        elm[ 0 ] = 0;
        elm[ 1 ] = temp;
        elm[ 2 ] = ( i + 1 ).toString();
        cat.push(elm);
    }
    
    this._primitive.addTic(cat);
    
});



defineProperty( barplot.prototype, 'xaxis', {
	'configurable': false,
	'enumerable': true,
	'set': setXaxis,
	'get': getXaxis
});

defineProperty( barplot.prototype, 'yaxis', {
	'configurable': false,
	'enumerable': true,
	'set': setYaxis,
	'get': getYaxis
});

defineProperty( barplot.prototype, 'rows', {
	'configurable': false,
	'enumerable': true,
	'set': setRows,
	'get': getRows
});

defineProperty( barplot.prototype, 'cols', {
	'configurable': false,
	'enumerable': true,
	'set': setCols,
	'get': getCols
});

defineProperty( barplot.prototype, 'vertical', {
	'configurable': false,
	'enumerable': true,
	'set': setVertical,
	'get': getVertical
});


function scale_bar ( x, y, containerWidth ) {
    var width = 0.8;
    var dataPoints = x.length;
    var awidth =  Math.floor( containerWidth / dataPoints );
    width = width * ( ( containerWidth / dataPoints ) * ( 10 / 101 )  );
    // 0.8 is the max width we can use because we also need to care about the spaces between bars
    width  = Math.min( width , 0.8 )


    // this normalization is done to reduce the rounding error, effect of this can be seen when the width is of  16 char or less and there is  14 plot 
    var widthWG = Math.floor( awidth * width );
    width = width * ( widthWG / ( awidth * width ) );

    var bins = x.length;
    
    var width_half = width / 2;
    var xbar = [];
    var ybar = [];

    for (let i = 0; i < bins; i++) {
        xbar.push([x[i] - width_half, x[i] + width_half]);
        ybar.push([0, y[i]]);
    }

    return [xbar, ybar];
}


function scale_bar_vertical ( x, y, containerWidth ) {
    var width = 0.2;
    var dataPoints = x.length;
    var awidth =  Math.floor( containerWidth / dataPoints );
    width = width * ( ( containerWidth / dataPoints ) * ( 7 / 12 )  );
    width  = Math.min( width , 0.8 )

    var bins = x.length;
    
    var width_half = width / 2;
    var xbar = [];
    var ybar = [];

    for (let i = 0; i < bins; i++) {
        xbar.push( [ i - width_half + 1, i + width_half + 1]);
        ybar.push([0, y[i]]);
    }

    return [xbar, ybar];
}

function minmax( elms ) {
    

    var min = Infinity ;
    var max = -Infinity;
    var elm;
    for ( elm of elms ) {
        min = Math.min( elm, min );
        max = Math.max(elm , max);
    }

    return [min, max];
}

function scale (elms, bins, lim, pad) {
    var elm;
    var arr=[];
    var i;
    var sElm;
    for ( i = 0; i < elms.length; i++ ) {
        elm = elms[i];
        sElm = ( elm - lim[0] ) / ( lim[1] - lim[0] );
        arr.push( Math.round( pad + ( ( bins - 1 ) * sElm ) ) )
        // arr.push(  )
    }
    return arr;
}


function getLim(elms) {
    var min = Infinity;
    var max = -Infinity;

    elms.forEach(arr => {
        min = Math.min(min, ...arr);
        max = Math.max(max, ...arr);
    });

    return [min, max];
}

module.exports = barplot