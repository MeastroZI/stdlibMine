/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable max-len */
/* eslint-disable no-invalid-this */
/* eslint-disable no-restricted-syntax */

'use strict';

// MODULES //

var defineProperty = require( '@stdlib/utils/define-property' );
var minn = require( '@stdlib/math/base/special/minn' );
var maxn = require( '@stdlib/math/base/special/maxn' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var mergeFcn = require( '@stdlib/utils/merge' ).factory;
var objectKeys = require( '@stdlib/utils/keys' );
var min = require( '@stdlib/math/base/special/min' );
var max = require( '@stdlib/math/base/special/max' );
var setSize= require( './props/setSize/set.js' );
var getSize = require( './props/setSize/get.js' );
var setpadTop= require( './props/padTop/set.js' );
var getpadTop = require( './props/padTop/get.js' );
var setpadBottom= require( './props/padBottom/set.js' );
var getpadBottom = require( './props/padBottom/get.js' );
var setpadLeft = require( './props/padLeft/set.js' );
var getpadLeft = require( './props/padLeft/get.js' );
var setpadRight = require( './props/padRight/set.js' );
var getpadRight = require( './props/padRight/get.js' );
var Pallete = require( './pallete.js' );
var defaults = require( './default.js' );


// VARIABLES //

// List of private properties (note: keep in alphabetical order):
var PRIVATE_PROPS = [
	'_cols',
	'_padBottom',
	'_padLeft',
	'_padRight',
	'_padTop',
	'_rows',
	'_setSize'
];


// FUNCTIONS //

var merge = mergeFcn({
	'extend': false
});


// MAIN //

/**
* PlotBase constructor.
*
* @constructor
* @param {Options} options - constructor options
* @param {number} [Options.padBottom] - padding bottom
* @param {number} [Options.padLeft] - padding left
* @param {number} [Options.padRight] - padding right
* @param {number} [Options.padTop] - padding top
* @param {Object} [Options.setSize] - size object with character width and height
* @throws {TypeError} must provide valid options
* @returns {PlotBase} PlotBase instance
*
* @example
* var PlotBase = new PlotBase();
*/
function PlotBase( ) {
	var options;
	var nargs;
	var keys;
	var opts;
	var key;
	var i;

	defineProperty( this, '_x', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': []
	});

	defineProperty( this, '_y', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': []
	});

	defineProperty( this, '_marker', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': []
	});

	defineProperty( this, '_color', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': []
	});

	defineProperty( this, '_palt', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': new Pallete(this)
	});

	for ( i = 0; i < PRIVATE_PROPS; i++ ) {
		defineProperty( this, PRIVATE_PROPS[ i ], {
			'configurable': false,
			'enumerable': false,
			'writable': true,
			'value': null
		});
	}

	nargs = arguments.length;
	opts = defaults();
	if ( nargs ) {
		options = arguments[ 0 ];
	}
	else {
		options = {};
	}
	opts = merge( opts, options );
	keys = objectKeys( opts );
	for ( i = 0; i < keys.length; i++ ) {
		key = keys[ i ];
		this[ key ] = opts[ key ];
	}
	return this;
}

/**
 * Add all the ansi codes to the matrix.
 *
 * @name build
 * @memberof PlotBase.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(PlotBase.prototype, 'build', function build() {
	var finalC =[];
	var temp;
	var i;
	var j;

	for ( i = 0; i < this._x.length; i++ ) {
		finalC.push( fillCord( this._x[ i ], this._y[ i ] ) );
	}

	for ( i = 0; i < finalC.length; i++ ) {
		temp = finalC[ i ];
		for ( j = 0; j < temp.length; j++ ) {
			this._palt.setElement( temp[ j ][ 0 ], temp[ j ][ 1 ], this._marker[ i ], this._color[ i ] );
		}
	}
});

/**
 * Display the rendered plots.
 *
 * @name show
 * @memberof PlotBase.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(PlotBase.prototype, 'show', function show() {
	var canva = this._palt.setcanvas();
	process.stdout.write( canva );
});

/**
 * Fill all the metrices representing the each structure of plot.
 *
 * @name draw
 * @memberof PlotBase.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(PlotBase.prototype, 'draw', function draw( x, y, color, marker ) {
	this._x.push( x );
	this._y.push( y );
	this._marker.push( marker || ' ' );
	this._color.push( color || 'wh' );
});

/**
 * Logic for rectangle structure.
 *
 * @name drawRectangle
 * @memberof PlotBase.prototype
 * @type {Function}
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(PlotBase.prototype, 'drawRectangle', function drawRectangle( xb, yb, color, marker ) {
	var xm = minn.apply( null, xb );
	var xM = maxn.apply( null, xb );
	var ym = minn.apply( null, yb );
	var yM = maxn.apply( null, yb );
	var x = [ xm, xm, xM, xM, xm ];
	var y = [ ym, yM, yM, ym, ym ];
	this.draw( x, y, color, marker );
});

/**
 * Add label and tics to the axis.
 *
 * @name addTic
 * @memberof PlotBase.prototype
 * @type {Function}
 * @param {boolean} overwrite // weather overwrite is enable or not
 * @param {string} color // color code for the tics
 * @param {Array} x // tics and label for the bottom horizontel axis
 * @param {Array} y // tics and label for the left vertical axis
 * @param {Array} z // tics and label for the top horizontel axis
 * @param {Array} w // tics and label for the right horizontel axis
 * @param {boolean} overwrite
 * @returns {void}
 *
 */
setNonEnumerableReadOnly(PlotBase.prototype, 'addTic', function addTic( overwrite, color, x, y, z, w ) {
	var i;

	if ( x && x.length > 0 ) {
		for ( i = 0; i < x.length; i++ ) {
			this._palt.setElement( this._padBottom - 1, x[ i ][ 1 ], 'HorTic', color, overwrite );
			this._palt.addHorizontelString( x[ i ][ 0 ], x[ i ][ 1 ], x[ i ][ 2 ].toString(), color, overwrite );
		}
	}
	if ( z && z.length > 0 ) {
		for ( i = 0; i < z.length; i++ ) {
			this._palt.setElement( this._padBottom - 1, z[ i ][ 1 ], 'HorTic', color, overwrite );
			this._palt.addHorizontelString( z[ i ][ 0 ], z[ i ][ 1 ], z[ i ][ 2 ].toString(), color, overwrite );
		}
	}
	if ( y && y.length > 0 ) {
		for ( i = 0; i < y.length; i++ ) {
			this._palt.setElement( y[ i ][ 0 ], this._padLeft - 1, 'VerTic', color, overwrite );
			this._palt.addHorizontelString( y[ i ][ 0 ], y[ i ][ 1 ], y[ i ][ 2 ].toString(), color, overwrite );
		}
	}
	if ( w && w.length > 0 ) {
		for ( i = 0; i < w.length; i++ ) {
			this._palt.setElement( w[ i ][ 0 ], this._padLeft - 1, 'VerTic', color, overwrite );
			this._palt.addHorizontelString( w[ i ][ 0 ], w[ i ][ 1 ], w[ i ][ 2 ].toString(), color, overwrite );
		}
	}
});

/**
 * Draw the frame.
 *
 * @name drawFrame
 * @memberof PlotBase.prototype
 * @type {Function}
 * @param {boolean} overwrite // overwrite is enable or not
 * @param {string} color // color code for the frame
 * @returns {void}
 *
 */
setNonEnumerableReadOnly( PlotBase.prototype, 'drawFrame', function drawFrame( overwrite, color ) {
	var i;

	for ( i = this._padBottom-1; i < this._rows; i++ ) {
		this._palt.setElement( i, this._padLeft - 1, 'vertical', color, overwrite );
		this._palt.setElement( i, this._cols-1, 'vertical', color, overwrite );
	}

	for ( i = this._padLeft-1; i < this._cols; i++ ) {
		this._palt.setElement( this._padBottom - 1, i, 'horizontal', color, overwrite );
		this._palt.setElement( this._rows-1, i, 'horizontal', color, overwrite );
	}

	// Corners

	this._palt.setElement( this._padBottom - 1, this._padLeft - 1, 'LBcorner', color, true );
	this._palt.setElement( this._padBottom - 1, this._cols-1, 'RBcorner', color, true );
	this._palt.setElement( this._rows-1, this._padLeft - 1, 'LTcorner', color, true );
	this._palt.setElement( this._rows-1, this._cols-1, 'RTcorner', color, true );
});

/**
 * @name setSize
 * @memberof PlotBase.prototype
 * @type {Object}
 * @throws {TypeError}
 *
 */
defineProperty( PlotBase.prototype, 'setSize', {
	'configurable': false,
	'enumerable': true,
	'set': setSize,
	'get': getSize
});

/**
 * @name padBottom
 * @memberof PlotBase.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( PlotBase.prototype, 'padBottom', {
	'configurable': false,
	'enumerable': true,
	'set': setpadBottom,
	'get': getpadBottom
});

/**
 * @name padTop
 * @memberof PlotBase.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( PlotBase.prototype, 'padTop', {
	'configurable': false,
	'enumerable': true,
	'set': setpadTop,
	'get': getpadTop
});

/**
 * @name padLeft
 * @memberof PlotBase.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( PlotBase.prototype, 'padLeft', {
	'configurable': false,
	'enumerable': true,
	'set': setpadLeft,
	'get': getpadLeft
});

/**
 * @name padRight
 * @memberof PlotBase.prototype
 * @type {number}
 * @throws {TypeError}
 *
 */
defineProperty( PlotBase.prototype, 'padRight', {
	'configurable': false,
	'enumerable': true,
	'set': setpadRight,
	'get': getpadRight
});

/**
* Provide the cordinate under the closed structure to fill them.
* @private
* @name fillCord
* @type {Function}
* @param {Array} sx - vertices x cordinate of structure
* @param {Array} sy - vertices y cordinate of structure
* @returns {Array} cordinate of filled structure
* */
function fillCord( sx, sy ) {
	var lcord;
	var temp;
	var L1;
	var L2;
	var i;

	lcord = [];
	L1 = [];
	L2 = [];

	// If not closed structure fill is not possible
	if ( sx[ 0 ] !== sx[ sy.length - 1 ] || sx.length < 3 ) {
		return;
	}

	L1 = fillLine( [ sx[ 0 ], sx[ 1 ] ], [ sy[ 0 ], sy[ 1 ] ] );
	L2 = fillLine( [sx[ 2 ], sx[ 3 ] ], [ sy[ 2 ], sy[ 3 ] ] );

	for ( i = 0; i < L1.length; i++ ) {
		temp = fillLine( [ L1[ i ][ 0 ], L2[ i ][ 0 ] ], [ L1[ i ][ 1 ], L2[ i ][ 1 ] ] );
		lcord = lcord.concat(temp);
	}
	return lcord;
}

/**
* Provide the coordinates between 2 points for line.
*
* @private
*
* @name fillLine
* @type {Function}
* @param {Array} sx - x coordinates of points of line
* @param {Array} sy - y coordinates of points of line
* @returns {Array} Array of all coordinates of line
* */
function fillLine( sx, sy ) {
	var lcord =[];
	var mx;
	var Mx;
	var my;
	var My;
	var i;

	if ( sx.length < 2 ) {
		return;
	}

	mx = min( sx[ 0 ], sx[ 1 ] );
	Mx = max( sx[ 0 ], sx[ 1 ] );
	my = min( sy[ 0 ], sy[ 1 ] );
	My = max( sy[ 0 ], sy[ 1 ] );
	if ( Mx-mx === 0 ) {
		for ( i = my; i <= My; i++ ) {
			lcord.push( [ mx, i ] );
		}
		return lcord;
	}
	if ( My-my === 0 ) {
		for ( i = mx; i <= Mx; i++ ) {
			lcord.push( [ i, my ] );
		}
		return lcord;
	}
	return lcord;
}
module.exports= PlotBase;
