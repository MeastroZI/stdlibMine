var utilites = {
    scale_bar: function (x, y, containerWidth, dataPoints ) {
        var width = 0.5;

        // width_half = width_half * ( ( containerWidth / dataPoints ) * ( 10 / 101 )  );
        width = width * ( ( 10 / dataPoints ) * ( containerWidth / 101 ) );
        // 0.8 is the max width we can use because we also need to care about the spaces between bars
        width  = Math.min( width , 0.8 )
        
        // var actualWidth = containerWidth / dataPoints  ;
        // width *= ( Math.floor(actualWidth) / actualWidth );

        var bins = x.length;
        
        var width_half = width / 2;
        var xbar = [];
        var ybar = [];

        // if (bins > 1) {
        //     width_half *= ( ( (Math.max(...x) - Math.min(...x)) / (bins - 1) )  ) ;
        // }

        for (let i = 0; i < bins; i++) {
            xbar.push([x[i] - width_half, x[i] + width_half]);
            ybar.push([0, y[i]]);
        }

        return [xbar, ybar];
    },

    scale_for_canva: function (elms, bins, lim, pad) {
        var elm;
        var arr=[];
        var i;
        var sElm;
        for ( i = 0; i < elms.length; i++ ) {
            elm = elms[i];
            sElm = ( elm - lim[0] ) / ( lim[1] - lim[0] );
            arr.push( Math.round( pad + ( ( bins - 1 ) * sElm ) ) )
            // arr.push(  )
        }
        return arr;
    },


    getLims: function (elms) {
        var min = Infinity;
        var max = -Infinity;

        elms.forEach(arr => {
            min = Math.min(min, ...arr);
            max = Math.max(max, ...arr);
        });

        return [min, max];
    },

    fill: function (x, y) {
        var filledcords = [];
        for (let i = x[0]; i < x[1]; i++) {
            for (let j = y[0]; j < y[1]; j++) {
                filledcords.push([i, j]);
            }
        }
        return filledcords;
    },
    
    getTermSize: function () {
        return [process.stdout.rows, process.stdout.columns];
    },

    fillCord : function ( sx, sy ) {
        if ( sx[0] != sx[sy.length - 1]  || sx.length < 3  ) {
            return
        }
        var lcord =[];
        var L1 = [];
        var L2 = [];
        var temp;
        var i;
        var j;
        var k;

        L1 = this.fillLine( [sx[0], sx[1]], [sy[0], sy[1]] );
        L2 = this.fillLine( [sx[2], sx[3]], [sy[2], sy[3]] );

        for ( i = 0 ; i < L1.length; i++ ) {
            temp = this.fillLine( [ L1[i][0], L2[i][0] ] , [ L1[i][1], L2[i][1] ] );
            lcord.push( ...temp );
        }
        return lcord;
    },

    fillLine : function ( sx, sy ) {
        if ( sx.length < 2 ) {
            return;
        }
        var lcord =[];
        var slop;
        var mx;
        var Mx;
        var my;
        var My;
        var i;

        mx = Math.min( sx[0], sx[1] );
        Mx = Math.max( sx[0], sx[1] );
        my = Math.min( sy[0], sy[1] );
        My = Math.max( sy[0], sy[1] );
        if ( Mx-mx == 0 ) {
            for( i = my; i <= My; i++ ){
                lcord.push([ mx, i]);
            }
            return lcord;
        }
        if ( My-my== 0 ) {
            for( i = mx; i <= Mx; i++  ) {
                lcord.push( [ i, my] );
            }
            return lcord;
        }
        slop = (My-my)/(Mx-mx);
        for( i = mx; i <= Mx; i++ ) {
            lcord.push([ i, Math.floor( i * slop )]);
        }
        return lcord;
    }
};

module.exports = utilites;
